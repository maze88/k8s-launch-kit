package cmd

import (
	"fmt"
	"os"
	"slices"
	"strings"

	"github.com/spf13/cobra"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/nvidia/k8s-launch-kit/pkg/app"
	applog "github.com/nvidia/k8s-launch-kit/pkg/log"
	"github.com/nvidia/k8s-launch-kit/pkg/networkoperatorplugin"
	"github.com/nvidia/k8s-launch-kit/pkg/options"
)

var (
	logLevel              string
	fabric                string
	deploymentType        string
	multirail             bool
	spectrumX             bool
	ai                    bool
	prompt                string
	saveDeploymentFiles   string
	deploy                bool
	kubeconfig            string
	userConfig            string
	discoverClusterConfig bool
	saveClusterConfig     string
	logger                = log.Log.WithName("l8k")
	enabledPlugins        string
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "l8k",
	Short: "NVIDIA Kubernetes Launch Kit",
	Long: `
K8s Launch Kit (l8k) is a CLI tool for deploying and managing NVIDIA cloud-native solutions on Kubernetes. The tool helps provide flexible deployment workflows for optimal network performance with SR-IOV, RDMA, and other networking technologies.

### Discover Cluster Configuration
Deploy a minimal Network Operator profile to automatically discover your cluster's
network capabilities and hardware configuration by using --discover-cluster-config.
This phase can be skipped if you provide your own configuration file by using --user-config.
This phase requires --kubeconfig to be specified.

### Generate Deployment Files
Based on the discovered or provided configuration, 
generate a complete set of YAML deployment files for the selected network profile. 
Files can be saved to disk using --save-deployment-files.
The profile can be defined manually with --fabric, --deployment-type and --multirail flags,
OR generated by an LLM-assisted profile generator with --prompt.

### Deploy to Cluster
Apply the generated deployment files to your Kubernetes cluster by using --deploy. This phase requires --kubeconfig and can be skipped if --deploy is not specified.`,
	Run: func(cmd *cobra.Command, args []string) {
		enabledPlugins := parseEnabledPlugins(enabledPlugins)
		// Create application options from CLI flags
		options := options.Options{
			LogLevel:              logLevel,
			UserConfig:            userConfig,
			DiscoverClusterConfig: discoverClusterConfig,
			Fabric:                fabric,
			DeploymentType:        deploymentType,
			Multirail:             multirail,
			SpectrumX:             spectrumX,
			Ai:                    ai,
			Prompt:                prompt,
			SaveDeploymentFiles:   saveDeploymentFiles,
			Deploy:                deploy,
			Kubeconfig:            kubeconfig,
			SaveClusterConfig:     saveClusterConfig,
			EnabledPlugins:        enabledPlugins,
		}

		// Validate CLI configuration
		if err := validateConfig(options); err != nil {
			logger.Error(err, "Invalid command line arguments")
			os.Exit(1)
		}

		logger.Info("SaveConfig", "val", options)

		// Create and run the application
		launcher := app.New(options)
		if err := launcher.Run(); err != nil {
			fmt.Printf("\nFatal error: %s\n", err)
			fmt.Println()
			os.Exit(1)
		}
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)

	// Phase 0: Plugin flags
	rootCmd.Flags().StringVar(&enabledPlugins, "enabled-plugins", "network-operator", "Comma-separated list of plugins to enable")

	// Phase 1: Cluster discovery flags
	rootCmd.Flags().BoolVar(&discoverClusterConfig, "discover-cluster-config", false, "Deploy a thin Network Operator profile to discover cluster capabilities")
	rootCmd.Flags().StringVar(&saveClusterConfig, "save-cluster-config", "/opt/nvidia/k8s-launch-kit/cluster-config.yaml", "Save discovered cluster configuration to the specified path")
	rootCmd.Flags().StringVar(&userConfig, "user-config", "", "Use provided cluster configuration file instead of auto-discovery (skips cluster discovery)")

	// Phase 2: Deployment generation flags
	rootCmd.Flags().StringVar(&fabric, "fabric", "", "Select the fabric type to deploy (infiniband, ethernet)")
	rootCmd.Flags().StringVar(&deploymentType, "deployment-type", "", "Select the deployment type (sriov, rdma_shared, host_device)")
	rootCmd.Flags().BoolVar(&multirail, "multirail", false, "Enable multirail deployment")
	rootCmd.Flags().BoolVar(&spectrumX, "spectrum-x", false, "Enable Spectrum X deployment")
	rootCmd.Flags().BoolVar(&ai, "ai", false, "Enable AI deployment")
	rootCmd.Flags().StringVar(&prompt, "prompt", "", "Path to file with a prompt to use for LLM-assisted profile generation")
	rootCmd.Flags().StringVar(&saveDeploymentFiles, "save-deployment-files", "/opt/nvidia/k8s-launch-kit/deployment", "Save generated deployment files to the specified directory")

	// Phase 3: Cluster deployment flags
	rootCmd.Flags().BoolVar(&deploy, "deploy", false, "Deploy the generated files to the Kubernetes cluster")
	rootCmd.Flags().StringVar(&kubeconfig, "kubeconfig", "", "Path to kubeconfig file for cluster deployment (required when using --deploy)")
	// Log level flag
	rootCmd.PersistentFlags().StringVar(&logLevel, "log-level", "info", "Log level (debug, info, warn, error)")
}

// validateConfig validates the CLI flag combinations
func validateConfig(options options.Options) error {
	// At least one plugin should be enabled
	if len(options.EnabledPlugins) == 0 {
		return fmt.Errorf("no plugins enabled, use --enabled-plugins to enable plugins")
	}

	// Either user-config or discover-cluster-config should be provided
	if options.UserConfig == "" && !options.DiscoverClusterConfig {
		return fmt.Errorf("either --user-config or --discover-cluster-config must be provided")
	}

	// Both user-config and discover-cluster-config cannot be provided together
	if options.UserConfig != "" && options.DiscoverClusterConfig {
		return fmt.Errorf("--user-config and --discover-cluster-config cannot be used together")
	}

	// If discover-cluster-config is provided, kubeconfig should be too
	if options.DiscoverClusterConfig && options.Kubeconfig == "" {
		return fmt.Errorf("--discover-cluster-config requires --kubeconfig to be specified")
	}

	// If deploy is provided, kubeconfig should be too
	if options.Deploy && options.Kubeconfig == "" {
		return fmt.Errorf("--deploy requires --kubeconfig to be specified")
	}

	// Network Operator plugin rules
	if slices.Contains(options.EnabledPlugins, networkoperatorplugin.PluginName) {
		// If profile is selected, either save-deployment-files or deploy options should be provided
		if (options.Fabric != "" || options.DeploymentType != "" || options.Prompt != "") && options.SaveDeploymentFiles == "" && !options.Deploy {
			return fmt.Errorf("when --deployment-type or --prompt is specified, either --save-deployment-files or --deploy must be provided")
		}

		// Save-deployment-files or deploy can't work without profile
		if options.Fabric == "" && options.DeploymentType == "" && options.Prompt == "" && options.Deploy {
			return fmt.Errorf("--deploy requires --deployment-type or --prompt to be specified")
		}

		if options.Prompt != "" && (options.Fabric != "" || options.DeploymentType != "") {
			return fmt.Errorf("--fabric and --prompt cannot be used together")
		}

		if (options.DeploymentType != "" && options.Fabric == "") || (options.Fabric != "" && options.DeploymentType == "") {
			return fmt.Errorf("--deployment-type requires --fabric to be specified")
		}

		if options.Fabric != "" && !slices.Contains([]string{"infiniband", "ethernet"}, options.Fabric) {
			return fmt.Errorf("--fabric must be one of: infiniband, ethernet")
		}

		if options.DeploymentType != "" && !slices.Contains([]string{"sriov", "rdma_shared", "host_device"}, options.DeploymentType) {
			return fmt.Errorf("--deployment-type must be one of: sriov, rdma_shared, host_device")
		}
	}

	return nil
}

func parseEnabledPlugins(enabledPlugins string) []string {
	return strings.Split(enabledPlugins, ",")
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	// Initialize logging
	applog.InitLog()

	// Implementation for config initialization
	// This can be expanded later to read from config files
}
